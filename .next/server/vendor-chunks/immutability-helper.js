"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/immutability-helper";
exports.ids = ["vendor-chunks/immutability-helper"];
exports.modules = {

/***/ "(ssr)/./node_modules/immutability-helper/index.js":
/*!***************************************************!*\
  !*** ./node_modules/immutability-helper/index.js ***!
  \***************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction stringifiable(obj) {\n    // Safely stringify Object.create(null)\n    /* istanbul ignore next */\n    return typeof obj === 'object' && !('toString' in obj) ?\n        Object.prototype.toString.call(obj).slice(8, -1) :\n        obj;\n}\nvar isProduction = typeof process === 'object' && \"development\" === 'production';\nfunction invariant(condition, message) {\n    if (!condition) {\n        /* istanbul ignore next */\n        if (isProduction) {\n            throw new Error('Invariant failed');\n        }\n        throw new Error(message());\n    }\n}\nexports.invariant = invariant;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar splice = Array.prototype.splice;\nvar toString = Object.prototype.toString;\nfunction type(obj) {\n    return toString.call(obj).slice(8, -1);\n}\nvar assign = Object.assign || /* istanbul ignore next */ (function (target, source) {\n    getAllKeys(source).forEach(function (key) {\n        if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    });\n    return target;\n});\nvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function'\n    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }\n    /* istanbul ignore next */\n    : function (obj) { return Object.keys(obj); };\nfunction copy(object) {\n    return Array.isArray(object)\n        ? assign(object.constructor(object.length), object)\n        : (type(object) === 'Map')\n            ? new Map(object)\n            : (type(object) === 'Set')\n                ? new Set(object)\n                : (object && typeof object === 'object')\n                    ? assign(Object.create(Object.getPrototypeOf(object)), object)\n                    /* istanbul ignore next */\n                    : object;\n}\nvar Context = /** @class */ (function () {\n    function Context() {\n        this.commands = assign({}, defaultCommands);\n        this.update = this.update.bind(this);\n        // Deprecated: update.extend, update.isEquals and update.newContext\n        this.update.extend = this.extend = this.extend.bind(this);\n        this.update.isEquals = function (x, y) { return x === y; };\n        this.update.newContext = function () { return new Context().update; };\n    }\n    Object.defineProperty(Context.prototype, \"isEquals\", {\n        get: function () {\n            return this.update.isEquals;\n        },\n        set: function (value) {\n            this.update.isEquals = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Context.prototype.extend = function (directive, fn) {\n        this.commands[directive] = fn;\n    };\n    Context.prototype.update = function (object, $spec) {\n        var _this = this;\n        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;\n        if (!(Array.isArray(object) && Array.isArray(spec))) {\n            invariant(!Array.isArray(spec), function () { return \"update(): You provided an invalid spec to update(). The spec may \" +\n                \"not contain an array except as the value of $set, $push, $unshift, \" +\n                \"$splice or any custom command allowing an array value.\"; });\n        }\n        invariant(typeof spec === 'object' && spec !== null, function () { return \"update(): You provided an invalid spec to update(). The spec and \" +\n            \"every included key path must be plain objects containing one of the \" +\n            (\"following commands: \" + Object.keys(_this.commands).join(', ') + \".\"); });\n        var nextObject = object;\n        getAllKeys(spec).forEach(function (key) {\n            if (hasOwnProperty.call(_this.commands, key)) {\n                var objectWasNextObject = object === nextObject;\n                nextObject = _this.commands[key](spec[key], nextObject, spec, object);\n                if (objectWasNextObject && _this.isEquals(nextObject, object)) {\n                    nextObject = object;\n                }\n            }\n            else {\n                var nextValueForKey = type(object) === 'Map'\n                    ? _this.update(object.get(key), spec[key])\n                    : _this.update(object[key], spec[key]);\n                var nextObjectValue = type(nextObject) === 'Map'\n                    ? nextObject.get(key)\n                    : nextObject[key];\n                if (!_this.isEquals(nextValueForKey, nextObjectValue)\n                    || typeof nextValueForKey === 'undefined'\n                        && !hasOwnProperty.call(object, key)) {\n                    if (nextObject === object) {\n                        nextObject = copy(object);\n                    }\n                    if (type(nextObject) === 'Map') {\n                        nextObject.set(key, nextValueForKey);\n                    }\n                    else {\n                        nextObject[key] = nextValueForKey;\n                    }\n                }\n            }\n        });\n        return nextObject;\n    };\n    return Context;\n}());\nexports.Context = Context;\nvar defaultCommands = {\n    $push: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$push');\n        return value.length ? nextObject.concat(value) : nextObject;\n    },\n    $unshift: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$unshift');\n        return value.length ? value.concat(nextObject) : nextObject;\n    },\n    $splice: function (value, nextObject, spec, originalObject) {\n        invariantSplices(nextObject, spec);\n        value.forEach(function (args) {\n            invariantSplice(args);\n            if (nextObject === originalObject && args.length) {\n                nextObject = copy(originalObject);\n            }\n            splice.apply(nextObject, args);\n        });\n        return nextObject;\n    },\n    $set: function (value, _nextObject, spec) {\n        invariantSet(spec);\n        return value;\n    },\n    $toggle: function (targets, nextObject) {\n        invariantSpecArray(targets, '$toggle');\n        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n        targets.forEach(function (target) {\n            nextObjectCopy[target] = !nextObject[target];\n        });\n        return nextObjectCopy;\n    },\n    $unset: function (value, nextObject, _spec, originalObject) {\n        invariantSpecArray(value, '$unset');\n        value.forEach(function (key) {\n            if (Object.hasOwnProperty.call(nextObject, key)) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                delete nextObject[key];\n            }\n        });\n        return nextObject;\n    },\n    $add: function (values, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$add');\n        invariantSpecArray(values, '$add');\n        if (type(nextObject) === 'Map') {\n            values.forEach(function (_a) {\n                var key = _a[0], value = _a[1];\n                if (nextObject === originalObject && nextObject.get(key) !== value) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.set(key, value);\n            });\n        }\n        else {\n            values.forEach(function (value) {\n                if (nextObject === originalObject && !nextObject.has(value)) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.add(value);\n            });\n        }\n        return nextObject;\n    },\n    $remove: function (value, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$remove');\n        invariantSpecArray(value, '$remove');\n        value.forEach(function (key) {\n            if (nextObject === originalObject && nextObject.has(key)) {\n                nextObject = copy(originalObject);\n            }\n            nextObject.delete(key);\n        });\n        return nextObject;\n    },\n    $merge: function (value, nextObject, _spec, originalObject) {\n        invariantMerge(nextObject, value);\n        getAllKeys(value).forEach(function (key) {\n            if (value[key] !== nextObject[key]) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject[key] = value[key];\n            }\n        });\n        return nextObject;\n    },\n    $apply: function (value, original) {\n        invariantApply(value);\n        return value(original);\n    },\n};\nvar defaultContext = new Context();\nexports.isEquals = defaultContext.update.isEquals;\nexports.extend = defaultContext.extend;\nexports[\"default\"] = defaultContext.update;\n// @ts-ignore\nexports[\"default\"][\"default\"] = module.exports = assign(exports.default, exports);\n// invariants\nfunction invariantPushAndUnshift(value, spec, command) {\n    invariant(Array.isArray(value), function () { return \"update(): expected target of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(value) + \".\"; });\n    invariantSpecArray(spec[command], command);\n}\nfunction invariantSpecArray(spec, command) {\n    invariant(Array.isArray(spec), function () { return \"update(): expected spec of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(spec) + \". \" +\n        \"Did you forget to wrap your parameter in an array?\"; });\n}\nfunction invariantSplices(value, spec) {\n    invariant(Array.isArray(value), function () { return \"Expected $splice target to be an array; got \" + stringifiable(value); });\n    invariantSplice(spec.$splice);\n}\nfunction invariantSplice(value) {\n    invariant(Array.isArray(value), function () { return \"update(): expected spec of $splice to be an array of arrays; got \" + stringifiable(value) + \". \" +\n        \"Did you forget to wrap your parameters in an array?\"; });\n}\nfunction invariantApply(fn) {\n    invariant(typeof fn === 'function', function () { return \"update(): expected spec of $apply to be a function; got \" + stringifiable(fn) + \".\"; });\n}\nfunction invariantSet(spec) {\n    invariant(Object.keys(spec).length === 1, function () { return \"Cannot have more than one key in an object with $set\"; });\n}\nfunction invariantMerge(target, specValue) {\n    invariant(specValue && typeof specValue === 'object', function () { return \"update(): $merge expects a spec of type 'object'; got \" + stringifiable(specValue); });\n    invariant(target && typeof target === 'object', function () { return \"update(): $merge expects a target of type 'object'; got \" + stringifiable(target); });\n}\nfunction invariantMapOrSet(target, command) {\n    var typeOfTarget = type(target);\n    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', function () { return \"update(): \" + stringifiable(command) + \" expects a target of type Set or Map; got \" + stringifiable(typeOfTarget); });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tdXRhYmlsaXR5LWhlbHBlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxrQkFBZTtBQUNmO0FBQ0EsNkJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxrREFBa0Qsb0ZBQW9GLHFDQUFxQztBQUMzSztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0ZBQWtGO0FBQ25JLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0Esa0RBQWtELGdEQUFnRCwrQkFBK0I7QUFDakk7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFFQUFxRTtBQUN2SCxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLHNEQUFzRCw0REFBNEQsa0NBQWtDO0FBQ3BKO0FBQ0E7QUFDQSw0REFBNEQsZ0VBQWdFO0FBQzVIO0FBQ0E7QUFDQSx3RUFBd0UsMERBQTBELG1DQUFtQztBQUNySyxrRUFBa0UsNERBQTRELGdDQUFnQztBQUM5SjtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsc0ZBQXNGLHNDQUFzQztBQUMxTSIsInNvdXJjZXMiOlsid2VicGFjazovL2V0aC1iYXRjaC1kZXBvc2l0LXVpLW5leHRqcy8uL25vZGVfbW9kdWxlcy9pbW11dGFiaWxpdHktaGVscGVyL2luZGV4LmpzPzA5YTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBzdHJpbmdpZmlhYmxlKG9iaikge1xuICAgIC8vIFNhZmVseSBzdHJpbmdpZnkgT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICEoJ3RvU3RyaW5nJyBpbiBvYmopID9cbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpIDpcbiAgICAgICAgb2JqO1xufVxudmFyIGlzUHJvZHVjdGlvbiA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YXJpYW50IGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuaW52YXJpYW50ID0gaW52YXJpYW50O1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzcGxpY2UgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmZ1bmN0aW9uIHR5cGUob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKS5zbGljZSg4LCAtMSk7XG59XG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAoZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gICAgZ2V0QWxsS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufSk7XG52YXIgZ2V0QWxsS2V5cyA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nXG4gICAgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3Qua2V5cyhvYmopLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpOyB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7IH07XG5mdW5jdGlvbiBjb3B5KG9iamVjdCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iamVjdClcbiAgICAgICAgPyBhc3NpZ24ob2JqZWN0LmNvbnN0cnVjdG9yKG9iamVjdC5sZW5ndGgpLCBvYmplY3QpXG4gICAgICAgIDogKHR5cGUob2JqZWN0KSA9PT0gJ01hcCcpXG4gICAgICAgICAgICA/IG5ldyBNYXAob2JqZWN0KVxuICAgICAgICAgICAgOiAodHlwZShvYmplY3QpID09PSAnU2V0JylcbiAgICAgICAgICAgICAgICA/IG5ldyBTZXQob2JqZWN0KVxuICAgICAgICAgICAgICAgIDogKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICAgICAgPyBhc3NpZ24oT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSksIG9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBvYmplY3Q7XG59XG52YXIgQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0KCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0gYXNzaWduKHt9LCBkZWZhdWx0Q29tbWFuZHMpO1xuICAgICAgICB0aGlzLnVwZGF0ZSA9IHRoaXMudXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIERlcHJlY2F0ZWQ6IHVwZGF0ZS5leHRlbmQsIHVwZGF0ZS5pc0VxdWFscyBhbmQgdXBkYXRlLm5ld0NvbnRleHRcbiAgICAgICAgdGhpcy51cGRhdGUuZXh0ZW5kID0gdGhpcy5leHRlbmQgPSB0aGlzLmV4dGVuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZS5pc0VxdWFscyA9IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4ID09PSB5OyB9O1xuICAgICAgICB0aGlzLnVwZGF0ZS5uZXdDb250ZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IENvbnRleHQoKS51cGRhdGU7IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250ZXh0LnByb3RvdHlwZSwgXCJpc0VxdWFsc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlLmlzRXF1YWxzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUuaXNFcXVhbHMgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29udGV4dC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSwgZm4pIHtcbiAgICAgICAgdGhpcy5jb21tYW5kc1tkaXJlY3RpdmVdID0gZm47XG4gICAgfTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob2JqZWN0LCAkc3BlYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3BlYyA9ICh0eXBlb2YgJHNwZWMgPT09ICdmdW5jdGlvbicpID8geyAkYXBwbHk6ICRzcGVjIH0gOiAkc3BlYztcbiAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShvYmplY3QpICYmIEFycmF5LmlzQXJyYXkoc3BlYykpKSB7XG4gICAgICAgICAgICBpbnZhcmlhbnQoIUFycmF5LmlzQXJyYXkoc3BlYyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6IFlvdSBwcm92aWRlZCBhbiBpbnZhbGlkIHNwZWMgdG8gdXBkYXRlKCkuIFRoZSBzcGVjIG1heSBcIiArXG4gICAgICAgICAgICAgICAgXCJub3QgY29udGFpbiBhbiBhcnJheSBleGNlcHQgYXMgdGhlIHZhbHVlIG9mICRzZXQsICRwdXNoLCAkdW5zaGlmdCwgXCIgK1xuICAgICAgICAgICAgICAgIFwiJHNwbGljZSBvciBhbnkgY3VzdG9tIGNvbW1hbmQgYWxsb3dpbmcgYW4gYXJyYXkgdmFsdWUuXCI7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGludmFyaWFudCh0eXBlb2Ygc3BlYyA9PT0gJ29iamVjdCcgJiYgc3BlYyAhPT0gbnVsbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJ1cGRhdGUoKTogWW91IHByb3ZpZGVkIGFuIGludmFsaWQgc3BlYyB0byB1cGRhdGUoKS4gVGhlIHNwZWMgYW5kIFwiICtcbiAgICAgICAgICAgIFwiZXZlcnkgaW5jbHVkZWQga2V5IHBhdGggbXVzdCBiZSBwbGFpbiBvYmplY3RzIGNvbnRhaW5pbmcgb25lIG9mIHRoZSBcIiArXG4gICAgICAgICAgICAoXCJmb2xsb3dpbmcgY29tbWFuZHM6IFwiICsgT2JqZWN0LmtleXMoX3RoaXMuY29tbWFuZHMpLmpvaW4oJywgJykgKyBcIi5cIik7IH0pO1xuICAgICAgICB2YXIgbmV4dE9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgZ2V0QWxsS2V5cyhzcGVjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKF90aGlzLmNvbW1hbmRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFdhc05leHRPYmplY3QgPSBvYmplY3QgPT09IG5leHRPYmplY3Q7XG4gICAgICAgICAgICAgICAgbmV4dE9iamVjdCA9IF90aGlzLmNvbW1hbmRzW2tleV0oc3BlY1trZXldLCBuZXh0T2JqZWN0LCBzcGVjLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RXYXNOZXh0T2JqZWN0ICYmIF90aGlzLmlzRXF1YWxzKG5leHRPYmplY3QsIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlRm9yS2V5ID0gdHlwZShvYmplY3QpID09PSAnTWFwJ1xuICAgICAgICAgICAgICAgICAgICA/IF90aGlzLnVwZGF0ZShvYmplY3QuZ2V0KGtleSksIHNwZWNba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy51cGRhdGUob2JqZWN0W2tleV0sIHNwZWNba2V5XSk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRPYmplY3RWYWx1ZSA9IHR5cGUobmV4dE9iamVjdCkgPT09ICdNYXAnXG4gICAgICAgICAgICAgICAgICAgID8gbmV4dE9iamVjdC5nZXQoa2V5KVxuICAgICAgICAgICAgICAgICAgICA6IG5leHRPYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzRXF1YWxzKG5leHRWYWx1ZUZvcktleSwgbmV4dE9iamVjdFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB8fCB0eXBlb2YgbmV4dFZhbHVlRm9yS2V5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0T2JqZWN0ID09PSBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRPYmplY3QgPSBjb3B5KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUobmV4dE9iamVjdCkgPT09ICdNYXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0T2JqZWN0LnNldChrZXksIG5leHRWYWx1ZUZvcktleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0T2JqZWN0W2tleV0gPSBuZXh0VmFsdWVGb3JLZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV4dE9iamVjdDtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuQ29udGV4dCA9IENvbnRleHQ7XG52YXIgZGVmYXVsdENvbW1hbmRzID0ge1xuICAgICRwdXNoOiBmdW5jdGlvbiAodmFsdWUsIG5leHRPYmplY3QsIHNwZWMpIHtcbiAgICAgICAgaW52YXJpYW50UHVzaEFuZFVuc2hpZnQobmV4dE9iamVjdCwgc3BlYywgJyRwdXNoJyk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPyBuZXh0T2JqZWN0LmNvbmNhdCh2YWx1ZSkgOiBuZXh0T2JqZWN0O1xuICAgIH0sXG4gICAgJHVuc2hpZnQ6IGZ1bmN0aW9uICh2YWx1ZSwgbmV4dE9iamVjdCwgc3BlYykge1xuICAgICAgICBpbnZhcmlhbnRQdXNoQW5kVW5zaGlmdChuZXh0T2JqZWN0LCBzcGVjLCAnJHVuc2hpZnQnKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IHZhbHVlLmNvbmNhdChuZXh0T2JqZWN0KSA6IG5leHRPYmplY3Q7XG4gICAgfSxcbiAgICAkc3BsaWNlOiBmdW5jdGlvbiAodmFsdWUsIG5leHRPYmplY3QsIHNwZWMsIG9yaWdpbmFsT2JqZWN0KSB7XG4gICAgICAgIGludmFyaWFudFNwbGljZXMobmV4dE9iamVjdCwgc3BlYyk7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIGludmFyaWFudFNwbGljZShhcmdzKTtcbiAgICAgICAgICAgIGlmIChuZXh0T2JqZWN0ID09PSBvcmlnaW5hbE9iamVjdCAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5leHRPYmplY3QgPSBjb3B5KG9yaWdpbmFsT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwbGljZS5hcHBseShuZXh0T2JqZWN0LCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXh0T2JqZWN0O1xuICAgIH0sXG4gICAgJHNldDogZnVuY3Rpb24gKHZhbHVlLCBfbmV4dE9iamVjdCwgc3BlYykge1xuICAgICAgICBpbnZhcmlhbnRTZXQoc3BlYyk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgICR0b2dnbGU6IGZ1bmN0aW9uICh0YXJnZXRzLCBuZXh0T2JqZWN0KSB7XG4gICAgICAgIGludmFyaWFudFNwZWNBcnJheSh0YXJnZXRzLCAnJHRvZ2dsZScpO1xuICAgICAgICB2YXIgbmV4dE9iamVjdENvcHkgPSB0YXJnZXRzLmxlbmd0aCA/IGNvcHkobmV4dE9iamVjdCkgOiBuZXh0T2JqZWN0O1xuICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgbmV4dE9iamVjdENvcHlbdGFyZ2V0XSA9ICFuZXh0T2JqZWN0W3RhcmdldF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV4dE9iamVjdENvcHk7XG4gICAgfSxcbiAgICAkdW5zZXQ6IGZ1bmN0aW9uICh2YWx1ZSwgbmV4dE9iamVjdCwgX3NwZWMsIG9yaWdpbmFsT2JqZWN0KSB7XG4gICAgICAgIGludmFyaWFudFNwZWNBcnJheSh2YWx1ZSwgJyR1bnNldCcpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0T2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRPYmplY3QgPT09IG9yaWdpbmFsT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRPYmplY3QgPSBjb3B5KG9yaWdpbmFsT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5leHRPYmplY3Rba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXh0T2JqZWN0O1xuICAgIH0sXG4gICAgJGFkZDogZnVuY3Rpb24gKHZhbHVlcywgbmV4dE9iamVjdCwgX3NwZWMsIG9yaWdpbmFsT2JqZWN0KSB7XG4gICAgICAgIGludmFyaWFudE1hcE9yU2V0KG5leHRPYmplY3QsICckYWRkJyk7XG4gICAgICAgIGludmFyaWFudFNwZWNBcnJheSh2YWx1ZXMsICckYWRkJyk7XG4gICAgICAgIGlmICh0eXBlKG5leHRPYmplY3QpID09PSAnTWFwJykge1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0T2JqZWN0ID09PSBvcmlnaW5hbE9iamVjdCAmJiBuZXh0T2JqZWN0LmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0T2JqZWN0ID0gY29weShvcmlnaW5hbE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRPYmplY3Quc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dE9iamVjdCA9PT0gb3JpZ2luYWxPYmplY3QgJiYgIW5leHRPYmplY3QuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0T2JqZWN0ID0gY29weShvcmlnaW5hbE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRPYmplY3QuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0T2JqZWN0O1xuICAgIH0sXG4gICAgJHJlbW92ZTogZnVuY3Rpb24gKHZhbHVlLCBuZXh0T2JqZWN0LCBfc3BlYywgb3JpZ2luYWxPYmplY3QpIHtcbiAgICAgICAgaW52YXJpYW50TWFwT3JTZXQobmV4dE9iamVjdCwgJyRyZW1vdmUnKTtcbiAgICAgICAgaW52YXJpYW50U3BlY0FycmF5KHZhbHVlLCAnJHJlbW92ZScpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChuZXh0T2JqZWN0ID09PSBvcmlnaW5hbE9iamVjdCAmJiBuZXh0T2JqZWN0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbmV4dE9iamVjdCA9IGNvcHkob3JpZ2luYWxPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dE9iamVjdC5kZWxldGUoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXh0T2JqZWN0O1xuICAgIH0sXG4gICAgJG1lcmdlOiBmdW5jdGlvbiAodmFsdWUsIG5leHRPYmplY3QsIF9zcGVjLCBvcmlnaW5hbE9iamVjdCkge1xuICAgICAgICBpbnZhcmlhbnRNZXJnZShuZXh0T2JqZWN0LCB2YWx1ZSk7XG4gICAgICAgIGdldEFsbEtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlW2tleV0gIT09IG5leHRPYmplY3Rba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0T2JqZWN0ID09PSBvcmlnaW5hbE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0T2JqZWN0ID0gY29weShvcmlnaW5hbE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRPYmplY3Rba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV4dE9iamVjdDtcbiAgICB9LFxuICAgICRhcHBseTogZnVuY3Rpb24gKHZhbHVlLCBvcmlnaW5hbCkge1xuICAgICAgICBpbnZhcmlhbnRBcHBseSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZShvcmlnaW5hbCk7XG4gICAgfSxcbn07XG52YXIgZGVmYXVsdENvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuZXhwb3J0cy5pc0VxdWFscyA9IGRlZmF1bHRDb250ZXh0LnVwZGF0ZS5pc0VxdWFscztcbmV4cG9ydHMuZXh0ZW5kID0gZGVmYXVsdENvbnRleHQuZXh0ZW5kO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdENvbnRleHQudXBkYXRlO1xuLy8gQHRzLWlnbm9yZVxuZXhwb3J0cy5kZWZhdWx0LmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cyA9IGFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuLy8gaW52YXJpYW50c1xuZnVuY3Rpb24gaW52YXJpYW50UHVzaEFuZFVuc2hpZnQodmFsdWUsIHNwZWMsIGNvbW1hbmQpIHtcbiAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6IGV4cGVjdGVkIHRhcmdldCBvZiBcIiArIHN0cmluZ2lmaWFibGUoY29tbWFuZCkgKyBcIiB0byBiZSBhbiBhcnJheTsgZ290IFwiICsgc3RyaW5naWZpYWJsZSh2YWx1ZSkgKyBcIi5cIjsgfSk7XG4gICAgaW52YXJpYW50U3BlY0FycmF5KHNwZWNbY29tbWFuZF0sIGNvbW1hbmQpO1xufVxuZnVuY3Rpb24gaW52YXJpYW50U3BlY0FycmF5KHNwZWMsIGNvbW1hbmQpIHtcbiAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShzcGVjKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJ1cGRhdGUoKTogZXhwZWN0ZWQgc3BlYyBvZiBcIiArIHN0cmluZ2lmaWFibGUoY29tbWFuZCkgKyBcIiB0byBiZSBhbiBhcnJheTsgZ290IFwiICsgc3RyaW5naWZpYWJsZShzcGVjKSArIFwiLiBcIiArXG4gICAgICAgIFwiRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCB5b3VyIHBhcmFtZXRlciBpbiBhbiBhcnJheT9cIjsgfSk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnRTcGxpY2VzKHZhbHVlLCBzcGVjKSB7XG4gICAgaW52YXJpYW50KEFycmF5LmlzQXJyYXkodmFsdWUpLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkV4cGVjdGVkICRzcGxpY2UgdGFyZ2V0IHRvIGJlIGFuIGFycmF5OyBnb3QgXCIgKyBzdHJpbmdpZmlhYmxlKHZhbHVlKTsgfSk7XG4gICAgaW52YXJpYW50U3BsaWNlKHNwZWMuJHNwbGljZSk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnRTcGxpY2UodmFsdWUpIHtcbiAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJHNwbGljZSB0byBiZSBhbiBhcnJheSBvZiBhcnJheXM7IGdvdCBcIiArIHN0cmluZ2lmaWFibGUodmFsdWUpICsgXCIuIFwiICtcbiAgICAgICAgXCJEaWQgeW91IGZvcmdldCB0byB3cmFwIHlvdXIgcGFyYW1ldGVycyBpbiBhbiBhcnJheT9cIjsgfSk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnRBcHBseShmbikge1xuICAgIGludmFyaWFudCh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJGFwcGx5IHRvIGJlIGEgZnVuY3Rpb247IGdvdCBcIiArIHN0cmluZ2lmaWFibGUoZm4pICsgXCIuXCI7IH0pO1xufVxuZnVuY3Rpb24gaW52YXJpYW50U2V0KHNwZWMpIHtcbiAgICBpbnZhcmlhbnQoT2JqZWN0LmtleXMoc3BlYykubGVuZ3RoID09PSAxLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkNhbm5vdCBoYXZlIG1vcmUgdGhhbiBvbmUga2V5IGluIGFuIG9iamVjdCB3aXRoICRzZXRcIjsgfSk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnRNZXJnZSh0YXJnZXQsIHNwZWNWYWx1ZSkge1xuICAgIGludmFyaWFudChzcGVjVmFsdWUgJiYgdHlwZW9mIHNwZWNWYWx1ZSA9PT0gJ29iamVjdCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6ICRtZXJnZSBleHBlY3RzIGEgc3BlYyBvZiB0eXBlICdvYmplY3QnOyBnb3QgXCIgKyBzdHJpbmdpZmlhYmxlKHNwZWNWYWx1ZSk7IH0pO1xuICAgIGludmFyaWFudCh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6ICRtZXJnZSBleHBlY3RzIGEgdGFyZ2V0IG9mIHR5cGUgJ29iamVjdCc7IGdvdCBcIiArIHN0cmluZ2lmaWFibGUodGFyZ2V0KTsgfSk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnRNYXBPclNldCh0YXJnZXQsIGNvbW1hbmQpIHtcbiAgICB2YXIgdHlwZU9mVGFyZ2V0ID0gdHlwZSh0YXJnZXQpO1xuICAgIGludmFyaWFudCh0eXBlT2ZUYXJnZXQgPT09ICdNYXAnIHx8IHR5cGVPZlRhcmdldCA9PT0gJ1NldCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6IFwiICsgc3RyaW5naWZpYWJsZShjb21tYW5kKSArIFwiIGV4cGVjdHMgYSB0YXJnZXQgb2YgdHlwZSBTZXQgb3IgTWFwOyBnb3QgXCIgKyBzdHJpbmdpZmlhYmxlKHR5cGVPZlRhcmdldCk7IH0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immutability-helper/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/immutability-helper/index.js":
/*!***************************************************!*\
  !*** ./node_modules/immutability-helper/index.js ***!
  \***************************************************/
/***/ ((module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction stringifiable(obj) {\n    // Safely stringify Object.create(null)\n    /* istanbul ignore next */\n    return typeof obj === 'object' && !('toString' in obj) ?\n        Object.prototype.toString.call(obj).slice(8, -1) :\n        obj;\n}\nvar isProduction = typeof process === 'object' && \"development\" === 'production';\nfunction invariant(condition, message) {\n    if (!condition) {\n        /* istanbul ignore next */\n        if (isProduction) {\n            throw new Error('Invariant failed');\n        }\n        throw new Error(message());\n    }\n}\nexports.invariant = invariant;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar splice = Array.prototype.splice;\nvar toString = Object.prototype.toString;\nfunction type(obj) {\n    return toString.call(obj).slice(8, -1);\n}\nvar assign = Object.assign || /* istanbul ignore next */ (function (target, source) {\n    getAllKeys(source).forEach(function (key) {\n        if (hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n        }\n    });\n    return target;\n});\nvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function'\n    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }\n    /* istanbul ignore next */\n    : function (obj) { return Object.keys(obj); };\nfunction copy(object) {\n    return Array.isArray(object)\n        ? assign(object.constructor(object.length), object)\n        : (type(object) === 'Map')\n            ? new Map(object)\n            : (type(object) === 'Set')\n                ? new Set(object)\n                : (object && typeof object === 'object')\n                    ? assign(Object.create(Object.getPrototypeOf(object)), object)\n                    /* istanbul ignore next */\n                    : object;\n}\nvar Context = /** @class */ (function () {\n    function Context() {\n        this.commands = assign({}, defaultCommands);\n        this.update = this.update.bind(this);\n        // Deprecated: update.extend, update.isEquals and update.newContext\n        this.update.extend = this.extend = this.extend.bind(this);\n        this.update.isEquals = function (x, y) { return x === y; };\n        this.update.newContext = function () { return new Context().update; };\n    }\n    Object.defineProperty(Context.prototype, \"isEquals\", {\n        get: function () {\n            return this.update.isEquals;\n        },\n        set: function (value) {\n            this.update.isEquals = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Context.prototype.extend = function (directive, fn) {\n        this.commands[directive] = fn;\n    };\n    Context.prototype.update = function (object, $spec) {\n        var _this = this;\n        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;\n        if (!(Array.isArray(object) && Array.isArray(spec))) {\n            invariant(!Array.isArray(spec), function () { return \"update(): You provided an invalid spec to update(). The spec may \" +\n                \"not contain an array except as the value of $set, $push, $unshift, \" +\n                \"$splice or any custom command allowing an array value.\"; });\n        }\n        invariant(typeof spec === 'object' && spec !== null, function () { return \"update(): You provided an invalid spec to update(). The spec and \" +\n            \"every included key path must be plain objects containing one of the \" +\n            (\"following commands: \" + Object.keys(_this.commands).join(', ') + \".\"); });\n        var nextObject = object;\n        getAllKeys(spec).forEach(function (key) {\n            if (hasOwnProperty.call(_this.commands, key)) {\n                var objectWasNextObject = object === nextObject;\n                nextObject = _this.commands[key](spec[key], nextObject, spec, object);\n                if (objectWasNextObject && _this.isEquals(nextObject, object)) {\n                    nextObject = object;\n                }\n            }\n            else {\n                var nextValueForKey = type(object) === 'Map'\n                    ? _this.update(object.get(key), spec[key])\n                    : _this.update(object[key], spec[key]);\n                var nextObjectValue = type(nextObject) === 'Map'\n                    ? nextObject.get(key)\n                    : nextObject[key];\n                if (!_this.isEquals(nextValueForKey, nextObjectValue)\n                    || typeof nextValueForKey === 'undefined'\n                        && !hasOwnProperty.call(object, key)) {\n                    if (nextObject === object) {\n                        nextObject = copy(object);\n                    }\n                    if (type(nextObject) === 'Map') {\n                        nextObject.set(key, nextValueForKey);\n                    }\n                    else {\n                        nextObject[key] = nextValueForKey;\n                    }\n                }\n            }\n        });\n        return nextObject;\n    };\n    return Context;\n}());\nexports.Context = Context;\nvar defaultCommands = {\n    $push: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$push');\n        return value.length ? nextObject.concat(value) : nextObject;\n    },\n    $unshift: function (value, nextObject, spec) {\n        invariantPushAndUnshift(nextObject, spec, '$unshift');\n        return value.length ? value.concat(nextObject) : nextObject;\n    },\n    $splice: function (value, nextObject, spec, originalObject) {\n        invariantSplices(nextObject, spec);\n        value.forEach(function (args) {\n            invariantSplice(args);\n            if (nextObject === originalObject && args.length) {\n                nextObject = copy(originalObject);\n            }\n            splice.apply(nextObject, args);\n        });\n        return nextObject;\n    },\n    $set: function (value, _nextObject, spec) {\n        invariantSet(spec);\n        return value;\n    },\n    $toggle: function (targets, nextObject) {\n        invariantSpecArray(targets, '$toggle');\n        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n        targets.forEach(function (target) {\n            nextObjectCopy[target] = !nextObject[target];\n        });\n        return nextObjectCopy;\n    },\n    $unset: function (value, nextObject, _spec, originalObject) {\n        invariantSpecArray(value, '$unset');\n        value.forEach(function (key) {\n            if (Object.hasOwnProperty.call(nextObject, key)) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                delete nextObject[key];\n            }\n        });\n        return nextObject;\n    },\n    $add: function (values, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$add');\n        invariantSpecArray(values, '$add');\n        if (type(nextObject) === 'Map') {\n            values.forEach(function (_a) {\n                var key = _a[0], value = _a[1];\n                if (nextObject === originalObject && nextObject.get(key) !== value) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.set(key, value);\n            });\n        }\n        else {\n            values.forEach(function (value) {\n                if (nextObject === originalObject && !nextObject.has(value)) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject.add(value);\n            });\n        }\n        return nextObject;\n    },\n    $remove: function (value, nextObject, _spec, originalObject) {\n        invariantMapOrSet(nextObject, '$remove');\n        invariantSpecArray(value, '$remove');\n        value.forEach(function (key) {\n            if (nextObject === originalObject && nextObject.has(key)) {\n                nextObject = copy(originalObject);\n            }\n            nextObject.delete(key);\n        });\n        return nextObject;\n    },\n    $merge: function (value, nextObject, _spec, originalObject) {\n        invariantMerge(nextObject, value);\n        getAllKeys(value).forEach(function (key) {\n            if (value[key] !== nextObject[key]) {\n                if (nextObject === originalObject) {\n                    nextObject = copy(originalObject);\n                }\n                nextObject[key] = value[key];\n            }\n        });\n        return nextObject;\n    },\n    $apply: function (value, original) {\n        invariantApply(value);\n        return value(original);\n    },\n};\nvar defaultContext = new Context();\nexports.isEquals = defaultContext.update.isEquals;\nexports.extend = defaultContext.extend;\nexports[\"default\"] = defaultContext.update;\n// @ts-ignore\nexports[\"default\"][\"default\"] = module.exports = assign(exports.default, exports);\n// invariants\nfunction invariantPushAndUnshift(value, spec, command) {\n    invariant(Array.isArray(value), function () { return \"update(): expected target of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(value) + \".\"; });\n    invariantSpecArray(spec[command], command);\n}\nfunction invariantSpecArray(spec, command) {\n    invariant(Array.isArray(spec), function () { return \"update(): expected spec of \" + stringifiable(command) + \" to be an array; got \" + stringifiable(spec) + \". \" +\n        \"Did you forget to wrap your parameter in an array?\"; });\n}\nfunction invariantSplices(value, spec) {\n    invariant(Array.isArray(value), function () { return \"Expected $splice target to be an array; got \" + stringifiable(value); });\n    invariantSplice(spec.$splice);\n}\nfunction invariantSplice(value) {\n    invariant(Array.isArray(value), function () { return \"update(): expected spec of $splice to be an array of arrays; got \" + stringifiable(value) + \". \" +\n        \"Did you forget to wrap your parameters in an array?\"; });\n}\nfunction invariantApply(fn) {\n    invariant(typeof fn === 'function', function () { return \"update(): expected spec of $apply to be a function; got \" + stringifiable(fn) + \".\"; });\n}\nfunction invariantSet(spec) {\n    invariant(Object.keys(spec).length === 1, function () { return \"Cannot have more than one key in an object with $set\"; });\n}\nfunction invariantMerge(target, specValue) {\n    invariant(specValue && typeof specValue === 'object', function () { return \"update(): $merge expects a spec of type 'object'; got \" + stringifiable(specValue); });\n    invariant(target && typeof target === 'object', function () { return \"update(): $merge expects a target of type 'object'; got \" + stringifiable(target); });\n}\nfunction invariantMapOrSet(target, command) {\n    var typeOfTarget = type(target);\n    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', function () { return \"update(): \" + stringifiable(command) + \" expects a target of type Set or Map; got \" + stringifiable(typeOfTarget); });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW1tdXRhYmlsaXR5LWhlbHBlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0JBQWdCO0FBQ3JFO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxrQkFBZTtBQUNmO0FBQ0EsNkJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxrREFBa0Qsb0ZBQW9GLHFDQUFxQztBQUMzSztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0ZBQWtGO0FBQ25JLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0Esa0RBQWtELGdEQUFnRCwrQkFBK0I7QUFDakk7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFFQUFxRTtBQUN2SCxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLHNEQUFzRCw0REFBNEQsa0NBQWtDO0FBQ3BKO0FBQ0E7QUFDQSw0REFBNEQsZ0VBQWdFO0FBQzVIO0FBQ0E7QUFDQSx3RUFBd0UsMERBQTBELG1DQUFtQztBQUNySyxrRUFBa0UsNERBQTRELGdDQUFnQztBQUM5SjtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsc0ZBQXNGLHNDQUFzQztBQUMxTSIsInNvdXJjZXMiOlsid2VicGFjazovL2V0aC1iYXRjaC1kZXBvc2l0LXVpLW5leHRqcy8uL25vZGVfbW9kdWxlcy9pbW11dGFiaWxpdHktaGVscGVyL2luZGV4LmpzP2Q0NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBzdHJpbmdpZmlhYmxlKG9iaikge1xuICAgIC8vIFNhZmVseSBzdHJpbmdpZnkgT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICEoJ3RvU3RyaW5nJyBpbiBvYmopID9cbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpIDpcbiAgICAgICAgb2JqO1xufVxudmFyIGlzUHJvZHVjdGlvbiA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YXJpYW50IGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuaW52YXJpYW50ID0gaW52YXJpYW50O1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBzcGxpY2UgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmZ1bmN0aW9uIHR5cGUob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKS5zbGljZSg4LCAtMSk7XG59XG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAoZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gICAgZ2V0QWxsS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufSk7XG52YXIgZ2V0QWxsS2V5cyA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nXG4gICAgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3Qua2V5cyhvYmopLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpOyB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7IH07XG5mdW5jdGlvbiBjb3B5KG9iamVjdCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iamVjdClcbiAgICAgICAgPyBhc3NpZ24ob2JqZWN0LmNvbnN0cnVjdG9yKG9iamVjdC5sZW5ndGgpLCBvYmplY3QpXG4gICAgICAgIDogKHR5cGUob2JqZWN0KSA9PT0gJ01hcCcpXG4gICAgICAgICAgICA/IG5ldyBNYXAob2JqZWN0KVxuICAgICAgICAgICAgOiAodHlwZShvYmplY3QpID09PSAnU2V0JylcbiAgICAgICAgICAgICAgICA/IG5ldyBTZXQob2JqZWN0KVxuICAgICAgICAgICAgICAgIDogKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICAgICAgPyBhc3NpZ24oT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSksIG9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBvYmplY3Q7XG59XG52YXIgQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0KCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0gYXNzaWduKHt9LCBkZWZhdWx0Q29tbWFuZHMpO1xuICAgICAgICB0aGlzLnVwZGF0ZSA9IHRoaXMudXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIERlcHJlY2F0ZWQ6IHVwZGF0ZS5leHRlbmQsIHVwZGF0ZS5pc0VxdWFscyBhbmQgdXBkYXRlLm5ld0NvbnRleHRcbiAgICAgICAgdGhpcy51cGRhdGUuZXh0ZW5kID0gdGhpcy5leHRlbmQgPSB0aGlzLmV4dGVuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZS5pc0VxdWFscyA9IGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4ID09PSB5OyB9O1xuICAgICAgICB0aGlzLnVwZGF0ZS5uZXdDb250ZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IENvbnRleHQoKS51cGRhdGU7IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250ZXh0LnByb3RvdHlwZSwgXCJpc0VxdWFsc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlLmlzRXF1YWxzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUuaXNFcXVhbHMgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29udGV4dC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSwgZm4pIHtcbiAgICAgICAgdGhpcy5jb21tYW5kc1tkaXJlY3RpdmVdID0gZm47XG4gICAgfTtcbiAgICBDb250ZXh0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob2JqZWN0LCAkc3BlYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3BlYyA9ICh0eXBlb2YgJHNwZWMgPT09ICdmdW5jdGlvbicpID8geyAkYXBwbHk6ICRzcGVjIH0gOiAkc3BlYztcbiAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShvYmplY3QpICYmIEFycmF5LmlzQXJyYXkoc3BlYykpKSB7XG4gICAgICAgICAgICBpbnZhcmlhbnQoIUFycmF5LmlzQXJyYXkoc3BlYyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6IFlvdSBwcm92aWRlZCBhbiBpbnZhbGlkIHNwZWMgdG8gdXBkYXRlKCkuIFRoZSBzcGVjIG1heSBcIiArXG4gICAgICAgICAgICAgICAgXCJub3QgY29udGFpbiBhbiBhcnJheSBleGNlcHQgYXMgdGhlIHZhbHVlIG9mICRzZXQsICRwdXNoLCAkdW5zaGlmdCwgXCIgK1xuICAgICAgICAgICAgICAgIFwiJHNwbGljZSBvciBhbnkgY3VzdG9tIGNvbW1hbmQgYWxsb3dpbmcgYW4gYXJyYXkgdmFsdWUuXCI7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGludmFyaWFudCh0eXBlb2Ygc3BlYyA9PT0gJ29iamVjdCcgJiYgc3BlYyAhPT0gbnVsbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJ1cGRhdGUoKTogWW91IHByb3ZpZGVkIGFuIGludmFsaWQgc3BlYyB0byB1cGRhdGUoKS4gVGhlIHNwZWMgYW5kIFwiICtcbiAgICAgICAgICAgIFwiZXZlcnkgaW5jbHVkZWQga2V5IHBhdGggbXVzdCBiZSBwbGFpbiBvYmplY3RzIGNvbnRhaW5pbmcgb25lIG9mIHRoZSBcIiArXG4gICAgICAgICAgICAoXCJmb2xsb3dpbmcgY29tbWFuZHM6IFwiICsgT2JqZWN0LmtleXMoX3RoaXMuY29tbWFuZHMpLmpvaW4oJywgJykgKyBcIi5cIik7IH0pO1xuICAgICAgICB2YXIgbmV4dE9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgZ2V0QWxsS2V5cyhzcGVjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKF90aGlzLmNvbW1hbmRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFdhc05leHRPYmplY3QgPSBvYmplY3QgPT09IG5leHRPYmplY3Q7XG4gICAgICAgICAgICAgICAgbmV4dE9iamVjdCA9IF90aGlzLmNvbW1hbmRzW2tleV0oc3BlY1trZXldLCBuZXh0T2JqZWN0LCBzcGVjLCBvYmplY3QpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RXYXNOZXh0T2JqZWN0ICYmIF90aGlzLmlzRXF1YWxzKG5leHRPYmplY3QsIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlRm9yS2V5ID0gdHlwZShvYmplY3QpID09PSAnTWFwJ1xuICAgICAgICAgICAgICAgICAgICA/IF90aGlzLnVwZGF0ZShvYmplY3QuZ2V0KGtleSksIHNwZWNba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy51cGRhdGUob2JqZWN0W2tleV0sIHNwZWNba2V5XSk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRPYmplY3RWYWx1ZSA9IHR5cGUobmV4dE9iamVjdCkgPT09ICdNYXAnXG4gICAgICAgICAgICAgICAgICAgID8gbmV4dE9iamVjdC5nZXQoa2V5KVxuICAgICAgICAgICAgICAgICAgICA6IG5leHRPYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzRXF1YWxzKG5leHRWYWx1ZUZvcktleSwgbmV4dE9iamVjdFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB8fCB0eXBlb2YgbmV4dFZhbHVlRm9yS2V5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0T2JqZWN0ID09PSBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRPYmplY3QgPSBjb3B5KG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUobmV4dE9iamVjdCkgPT09ICdNYXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0T2JqZWN0LnNldChrZXksIG5leHRWYWx1ZUZvcktleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0T2JqZWN0W2tleV0gPSBuZXh0VmFsdWVGb3JLZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV4dE9iamVjdDtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuQ29udGV4dCA9IENvbnRleHQ7XG52YXIgZGVmYXVsdENvbW1hbmRzID0ge1xuICAgICRwdXNoOiBmdW5jdGlvbiAodmFsdWUsIG5leHRPYmplY3QsIHNwZWMpIHtcbiAgICAgICAgaW52YXJpYW50UHVzaEFuZFVuc2hpZnQobmV4dE9iamVjdCwgc3BlYywgJyRwdXNoJyk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPyBuZXh0T2JqZWN0LmNvbmNhdCh2YWx1ZSkgOiBuZXh0T2JqZWN0O1xuICAgIH0sXG4gICAgJHVuc2hpZnQ6IGZ1bmN0aW9uICh2YWx1ZSwgbmV4dE9iamVjdCwgc3BlYykge1xuICAgICAgICBpbnZhcmlhbnRQdXNoQW5kVW5zaGlmdChuZXh0T2JqZWN0LCBzcGVjLCAnJHVuc2hpZnQnKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IHZhbHVlLmNvbmNhdChuZXh0T2JqZWN0KSA6IG5leHRPYmplY3Q7XG4gICAgfSxcbiAgICAkc3BsaWNlOiBmdW5jdGlvbiAodmFsdWUsIG5leHRPYmplY3QsIHNwZWMsIG9yaWdpbmFsT2JqZWN0KSB7XG4gICAgICAgIGludmFyaWFudFNwbGljZXMobmV4dE9iamVjdCwgc3BlYyk7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIGludmFyaWFudFNwbGljZShhcmdzKTtcbiAgICAgICAgICAgIGlmIChuZXh0T2JqZWN0ID09PSBvcmlnaW5hbE9iamVjdCAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5leHRPYmplY3QgPSBjb3B5KG9yaWdpbmFsT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwbGljZS5hcHBseShuZXh0T2JqZWN0LCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXh0T2JqZWN0O1xuICAgIH0sXG4gICAgJHNldDogZnVuY3Rpb24gKHZhbHVlLCBfbmV4dE9iamVjdCwgc3BlYykge1xuICAgICAgICBpbnZhcmlhbnRTZXQoc3BlYyk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgICR0b2dnbGU6IGZ1bmN0aW9uICh0YXJnZXRzLCBuZXh0T2JqZWN0KSB7XG4gICAgICAgIGludmFyaWFudFNwZWNBcnJheSh0YXJnZXRzLCAnJHRvZ2dsZScpO1xuICAgICAgICB2YXIgbmV4dE9iamVjdENvcHkgPSB0YXJnZXRzLmxlbmd0aCA/IGNvcHkobmV4dE9iamVjdCkgOiBuZXh0T2JqZWN0O1xuICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgbmV4dE9iamVjdENvcHlbdGFyZ2V0XSA9ICFuZXh0T2JqZWN0W3RhcmdldF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV4dE9iamVjdENvcHk7XG4gICAgfSxcbiAgICAkdW5zZXQ6IGZ1bmN0aW9uICh2YWx1ZSwgbmV4dE9iamVjdCwgX3NwZWMsIG9yaWdpbmFsT2JqZWN0KSB7XG4gICAgICAgIGludmFyaWFudFNwZWNBcnJheSh2YWx1ZSwgJyR1bnNldCcpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0T2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRPYmplY3QgPT09IG9yaWdpbmFsT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRPYmplY3QgPSBjb3B5KG9yaWdpbmFsT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5leHRPYmplY3Rba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXh0T2JqZWN0O1xuICAgIH0sXG4gICAgJGFkZDogZnVuY3Rpb24gKHZhbHVlcywgbmV4dE9iamVjdCwgX3NwZWMsIG9yaWdpbmFsT2JqZWN0KSB7XG4gICAgICAgIGludmFyaWFudE1hcE9yU2V0KG5leHRPYmplY3QsICckYWRkJyk7XG4gICAgICAgIGludmFyaWFudFNwZWNBcnJheSh2YWx1ZXMsICckYWRkJyk7XG4gICAgICAgIGlmICh0eXBlKG5leHRPYmplY3QpID09PSAnTWFwJykge1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0T2JqZWN0ID09PSBvcmlnaW5hbE9iamVjdCAmJiBuZXh0T2JqZWN0LmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0T2JqZWN0ID0gY29weShvcmlnaW5hbE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRPYmplY3Quc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dE9iamVjdCA9PT0gb3JpZ2luYWxPYmplY3QgJiYgIW5leHRPYmplY3QuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0T2JqZWN0ID0gY29weShvcmlnaW5hbE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRPYmplY3QuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0T2JqZWN0O1xuICAgIH0sXG4gICAgJHJlbW92ZTogZnVuY3Rpb24gKHZhbHVlLCBuZXh0T2JqZWN0LCBfc3BlYywgb3JpZ2luYWxPYmplY3QpIHtcbiAgICAgICAgaW52YXJpYW50TWFwT3JTZXQobmV4dE9iamVjdCwgJyRyZW1vdmUnKTtcbiAgICAgICAgaW52YXJpYW50U3BlY0FycmF5KHZhbHVlLCAnJHJlbW92ZScpO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChuZXh0T2JqZWN0ID09PSBvcmlnaW5hbE9iamVjdCAmJiBuZXh0T2JqZWN0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbmV4dE9iamVjdCA9IGNvcHkob3JpZ2luYWxPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dE9iamVjdC5kZWxldGUoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXh0T2JqZWN0O1xuICAgIH0sXG4gICAgJG1lcmdlOiBmdW5jdGlvbiAodmFsdWUsIG5leHRPYmplY3QsIF9zcGVjLCBvcmlnaW5hbE9iamVjdCkge1xuICAgICAgICBpbnZhcmlhbnRNZXJnZShuZXh0T2JqZWN0LCB2YWx1ZSk7XG4gICAgICAgIGdldEFsbEtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlW2tleV0gIT09IG5leHRPYmplY3Rba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0T2JqZWN0ID09PSBvcmlnaW5hbE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0T2JqZWN0ID0gY29weShvcmlnaW5hbE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRPYmplY3Rba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV4dE9iamVjdDtcbiAgICB9LFxuICAgICRhcHBseTogZnVuY3Rpb24gKHZhbHVlLCBvcmlnaW5hbCkge1xuICAgICAgICBpbnZhcmlhbnRBcHBseSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZShvcmlnaW5hbCk7XG4gICAgfSxcbn07XG52YXIgZGVmYXVsdENvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuZXhwb3J0cy5pc0VxdWFscyA9IGRlZmF1bHRDb250ZXh0LnVwZGF0ZS5pc0VxdWFscztcbmV4cG9ydHMuZXh0ZW5kID0gZGVmYXVsdENvbnRleHQuZXh0ZW5kO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdENvbnRleHQudXBkYXRlO1xuLy8gQHRzLWlnbm9yZVxuZXhwb3J0cy5kZWZhdWx0LmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cyA9IGFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuLy8gaW52YXJpYW50c1xuZnVuY3Rpb24gaW52YXJpYW50UHVzaEFuZFVuc2hpZnQodmFsdWUsIHNwZWMsIGNvbW1hbmQpIHtcbiAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6IGV4cGVjdGVkIHRhcmdldCBvZiBcIiArIHN0cmluZ2lmaWFibGUoY29tbWFuZCkgKyBcIiB0byBiZSBhbiBhcnJheTsgZ290IFwiICsgc3RyaW5naWZpYWJsZSh2YWx1ZSkgKyBcIi5cIjsgfSk7XG4gICAgaW52YXJpYW50U3BlY0FycmF5KHNwZWNbY29tbWFuZF0sIGNvbW1hbmQpO1xufVxuZnVuY3Rpb24gaW52YXJpYW50U3BlY0FycmF5KHNwZWMsIGNvbW1hbmQpIHtcbiAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShzcGVjKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJ1cGRhdGUoKTogZXhwZWN0ZWQgc3BlYyBvZiBcIiArIHN0cmluZ2lmaWFibGUoY29tbWFuZCkgKyBcIiB0byBiZSBhbiBhcnJheTsgZ290IFwiICsgc3RyaW5naWZpYWJsZShzcGVjKSArIFwiLiBcIiArXG4gICAgICAgIFwiRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCB5b3VyIHBhcmFtZXRlciBpbiBhbiBhcnJheT9cIjsgfSk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnRTcGxpY2VzKHZhbHVlLCBzcGVjKSB7XG4gICAgaW52YXJpYW50KEFycmF5LmlzQXJyYXkodmFsdWUpLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkV4cGVjdGVkICRzcGxpY2UgdGFyZ2V0IHRvIGJlIGFuIGFycmF5OyBnb3QgXCIgKyBzdHJpbmdpZmlhYmxlKHZhbHVlKTsgfSk7XG4gICAgaW52YXJpYW50U3BsaWNlKHNwZWMuJHNwbGljZSk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnRTcGxpY2UodmFsdWUpIHtcbiAgICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJHNwbGljZSB0byBiZSBhbiBhcnJheSBvZiBhcnJheXM7IGdvdCBcIiArIHN0cmluZ2lmaWFibGUodmFsdWUpICsgXCIuIFwiICtcbiAgICAgICAgXCJEaWQgeW91IGZvcmdldCB0byB3cmFwIHlvdXIgcGFyYW1ldGVycyBpbiBhbiBhcnJheT9cIjsgfSk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnRBcHBseShmbikge1xuICAgIGludmFyaWFudCh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJGFwcGx5IHRvIGJlIGEgZnVuY3Rpb247IGdvdCBcIiArIHN0cmluZ2lmaWFibGUoZm4pICsgXCIuXCI7IH0pO1xufVxuZnVuY3Rpb24gaW52YXJpYW50U2V0KHNwZWMpIHtcbiAgICBpbnZhcmlhbnQoT2JqZWN0LmtleXMoc3BlYykubGVuZ3RoID09PSAxLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIkNhbm5vdCBoYXZlIG1vcmUgdGhhbiBvbmUga2V5IGluIGFuIG9iamVjdCB3aXRoICRzZXRcIjsgfSk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnRNZXJnZSh0YXJnZXQsIHNwZWNWYWx1ZSkge1xuICAgIGludmFyaWFudChzcGVjVmFsdWUgJiYgdHlwZW9mIHNwZWNWYWx1ZSA9PT0gJ29iamVjdCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6ICRtZXJnZSBleHBlY3RzIGEgc3BlYyBvZiB0eXBlICdvYmplY3QnOyBnb3QgXCIgKyBzdHJpbmdpZmlhYmxlKHNwZWNWYWx1ZSk7IH0pO1xuICAgIGludmFyaWFudCh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6ICRtZXJnZSBleHBlY3RzIGEgdGFyZ2V0IG9mIHR5cGUgJ29iamVjdCc7IGdvdCBcIiArIHN0cmluZ2lmaWFibGUodGFyZ2V0KTsgfSk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnRNYXBPclNldCh0YXJnZXQsIGNvbW1hbmQpIHtcbiAgICB2YXIgdHlwZU9mVGFyZ2V0ID0gdHlwZSh0YXJnZXQpO1xuICAgIGludmFyaWFudCh0eXBlT2ZUYXJnZXQgPT09ICdNYXAnIHx8IHR5cGVPZlRhcmdldCA9PT0gJ1NldCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwidXBkYXRlKCk6IFwiICsgc3RyaW5naWZpYWJsZShjb21tYW5kKSArIFwiIGV4cGVjdHMgYSB0YXJnZXQgb2YgdHlwZSBTZXQgb3IgTWFwOyBnb3QgXCIgKyBzdHJpbmdpZmlhYmxlKHR5cGVPZlRhcmdldCk7IH0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/immutability-helper/index.js\n");

/***/ })

};
;